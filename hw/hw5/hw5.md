## 1

### (1)
在“每次删除最大的可删除元素”的基础上，采用这样的策略：
对当前决定删除的最大可删除元素，由于左边或右边必然有一个元素比它小1，因此朝另一边探测，找到由和该元素相等元素组成的最长连续序列，将该序列一并删除。
> 如：对数列9，9，9，8，6，首先选中的最大可删除元素是第3个9，它右边的8比它小1，因此往左边探测，得到3个连续的9，便可以将这3个9一起删除。

采用这样的数据结构解决该问题：用一个双向循环链表按原顺序存储给定的整数序列，再用一个由指向链表节点的指针组成的指针数组，按节点对应的元素从大到小的顺序存储链表中节点的指针。这样就可以顺着指针数组从大到小的顺序遍历链表，找到最大可删除元素，按上面的策略进行删除。

唯一需要考虑的问题是，会不会出现删除了指针数组中靠后的某一指针q对应的元素后，前面的某一指针p对应的元素（原本不可删除）变为可删除的情况。这种情况下，p对应元素必然和q对应元素直接相邻，且它们的值相等，按上面的删除策略，p对应元素必然会被一起删除。因此这种情况决不会发生。

下面给出C语言风格的伪代码：
```C
typedef struct DLNode {
    int value, del;//用del表示该节点是否已被删除
    struct DLNode *prev, *next;
} DLNode, *DList;
void mergeSort(DList arr[], int l, int r) {//按节点对应元素从大到小排序
    //归并排序
    if(l >= r) return;
    int mid = (l+r)/2;
    mergeSort(arr, l, mid);
    mergeSort(arr, mid+1, r);
    DList temp[r-l+1];
    int i = l, j = mid+1, k = 0;
    while(i <= mid && j <= r) {
        if(arr[i]->value > arr[j]->value) temp[k++] = arr[i++];
        else temp[k++] = arr[j++];
    }
    while(i <= mid) temp[k++] = arr[i++];
    while(j <= r) temp[k++] = arr[j++];
    for(int i = l; i <= r; i++) arr[i] = temp[i-l];
    return;
}
int deleteNum(int num[], int n) {
    int count = 0;
    DList Head = (DList)malloc(sizeof(DLNode));
    Head->prev = Head->next = Head;
    Head->value = inf;//inf表示正无穷
    Head->del = 0;
    DList prev = Head;
    DList pArr[n];//指针数组
    for(int i = 0; i < n; i++) {
        DList p = (DList)malloc(sizeof(DLNode));
        pArr[i] = p;
        p->value = num[i];
        p->del = 0;
        p->prev = prev;
        p->next = NULL;
        prev->next = p;
        prev = p;
    }
    mergeSort(pArr, 0, n-1);//按节点对应元素从大到小排序
    for(int i = 0; i < n; i++) {
        DList p = pArr[i];
        if(p->del) continue;//遇到已删除的节点，跳过
        while(p && p->prev && p->prev->value==p->value-1) {//左边的比它小1，用while可以连续删除一串相等元素
            DList q = p->next;
            p->prev->next=p->next;
            if(p->next)//防止p是最后一个节点
                p->next->prev=p->prev;
            p->del = 1;
            p=q;
            count++;
        }
        while(p && p->next && p->next->value==p->value-1) {//右边的比它小1，用while可以连续删除一串相等元素
            DList q = p->prev;
            if(p->prev)//防止p是第一个节点
                p->prev->next=p->next;
            p->next->prev=p->prev;
            p->del = 1;
            p=q;
            count++;
        }
    }
    for(int i = 0; i < n; i++) free(pArr[i]);//最后再释放
    free(Head);
    return count;
}
```

最坏时间复杂度：
算法分为几部分。首先创建双向链表和填充指针数组的过程显然是$O(n)$的（因为循环n次，每次循环执行常数次操作）。随后的归并排序最坏为$O(n\log n)$。最后的删除过程，尽管是for循环中嵌套while循环，但是考虑每个节点，有如下几种情况：
- 1. 该节点在被外层for循环选中时还未被删除，随后一直未被删除，因此该节点只被访问一次。
- 2. 该节点在被外层for循环选中时还未被删除，随后在for循环内被删除，之后也不会再访问该节点，因此也只被访问一次。
- 3. 该节点在被外层for循环选中时还未被删除，在这一次for循环执行时也未被删除，但是在之后的某个节点被删除时连带着被删除，因此该节点被访问了两次。
- 4. 该节点先在前面的某个节点被删除时被连带着删除，在for循环遍历到它时，发现已被删除，continue。因此该节点被访问了两次。

总之，每个节点至多被访问2次。因此这个过程的最坏时间复杂度为$O(n)$。

最后的free过程是$O(n)$的。其余的建立头节点等操作都是常数代价的。

因此整个算法的最坏时间复杂度为$O(n\log n)$。

### (2)
#### (2.1)
证明：不妨设$j>i$。由于在删除**x**中元素时，删除$x_k, k<i \bigcup k>j$的元素不会影响$x_i$和$x_j$之间元素的可删除性，删除$x_i$和$x_j$之间的元素也不会影响它们两边的元素的可删除性，因此只需要考虑对$x_i$和$x_j$之间的元素的操作即可。

假设可以通过一系列操作使$x_i$和$x_j$相邻，那么这一系列操作会删除$x_i$和$x_j$之间的所有元素。考虑$x_i$和$x_j$之间最后一个被删除的元素$x_{-1}$，它被删除时与$x_i$和$x_j$相邻，因此必然大于等于$x_j$（可以取$x_i+1$，即$x_j$，或$x_j+1$）。同理，对于$x_i$和$x_j$之间倒数第二个被删除的元素$x_{-2}$，它被删除时与$x_i$，$x_j$和$x_{-1}$中的两个相邻，也一定大于等于$x_j$。一直这样重复下去，可以推知$x_i$和$x_j$之间的所有元素都大于等于$x_j$。那么，$x_i$和$x_j$之间第一个被删除的元素也大于等于$x_j$，与$x_i$是当前可删除的最大元素矛盾。

因此，不可能通过一系列操作使$x_i$和$x_j$相邻。

#### (2.2)
首先证明：删除$x_i$后，不会使**x**中除$x_i$外可删除的元素数量减少。

显然，删除某个元素后，只会影响与它相邻的两个元素的可删除性。因此只需讨论删除
$x_i$前后，$x_{i-1}$和$x_{i+1}$的可删除性。假设删除$x_i$后，$x_{i-1}$和$x_{i+1}$中某个原本可删除的元素变为不可删除，不妨设这个元素是$x_{i+1}$。由于$x_i$是当前可删除的最大元素，因此$x_{i+1}$不可能为$x_i+1$，那么$x_{i+2}$必然为$x_{i+1}-1$（否则$x_{i+1}$不可删除）。因此，删除$x_i$后，原本的$x_{i+2}$仍与原本的$x_{i+1}$相邻，$x_{i+1}$仍是可删除的。不存在$x_{i+1}$变为不可删除的情况。

因此，对于$\forall d \in D$，若d中不包含$x_i$，则将$x_i$加到d的头部得到d'，d'仍是一个合法删除序列，且长度更长；若d中包含$x_i$，则把$x_i$移动到d的头部得到d'，则d'仍是一个合法删除序列，且长度不变。

因此，存在$\phi : D \rightarrow D'$，使得$\forall d \in D$，$\phi(d)$不短于$d$。

### (3)
将(1)中的排序算法换成计数排序。计数排序的时间复杂度恒为$O(m+n)$，其余部分至多是$O(n)$的。因此整个算法的最坏时间复杂度为$O(m+n)$。


## 2
### (1)
只需计算初始时$x_1, x_2, ..., x_n$中长度为k的连续子序列和的最大值，再加上$1+2+...+k-1$即可。为方便描述，给出伪代码如下：
```C
int maxComputer(int x[], int n, int k) {
    int sum = 0;
    for(int i = 0; i < k; i++) sum += x[i];
    int max = sum;
    for(int i = k; i < n; i++) {
        sum += x[i] - x[i-k];
        if(sum > max) max = sum;
    }
    return max + k*(k-1)/2;
}
```
这个算法显然是$O(n)$的。

### (2)
将缴获的电脑数分为两部分：原有的电脑数和新增的电脑数。
- 对于原有的电脑：我们访问的宿舍是连续的，且最多只能访问k间宿舍。由于使得缴获的原有电脑最多的策略必然访问了k间宿舍（否则若只访问少于k间宿舍，则任意多访问一间相邻的宿舍就可以使缴获的原有电脑数更多），因此缴获的原有的电脑数最多为长度为k的连续子序列和的最大值。该上限是一定能达到的，只需按顺序访问组成该最大值的k间宿舍即可。
- 对于新增的电脑：考虑在第j天进入的宿舍。如果这间宿舍之前还没有进入过，则缴获的新增电脑数为j-1；如果此前在第j-s天进入过（s < j），则只能缴获s台电脑。因此，第j天最多只能缴获j-1台新增电脑，缴获的新增电脑数最多为1+2+...+k-1。只需要每天进入一间新宿舍即可达到该上限，因此访问k间宿舍必然达到该上限，即使得缴获的原有的电脑最多的方案，也一定缴获最多的新增电脑。

综上，缴获的电脑数最多为长度为k的连续子序列和的最大值加上1+2+...+k-1，且存在策略可以达到该最大值。该算法是正确的。


## 3
### (1)
使用归并排序求升序排列即可。

### (2)
使用归并排序求降序排列即可。


## 4
### (1)
#### (1.1)
考虑序列`(,(,*,)`。如果调换顺序，则第一遍扫描到右括号时会将星号匹配，剩余的序列是`(,(`，显然第二遍扫描时会得到false。但如果不调换顺序，第一遍扫描到右括号时会将左括号匹配，剩余的序列是`(*`，第二遍扫描时会得到true。事实上结果确实应该是true。
#### (1.2)
考虑序列`(,*,(,)`，如果第一遍中匹配左侧最左边的左括号，则第一遍扫描后剩下`*,(`，第二遍扫描为false。但如果第一遍中匹配右侧最右边的左括号，则第一遍扫描后剩下`(,*`，第二遍扫描为true。结果应该为true。
#### (1.3)
考虑`(,*,(,*`，第一遍扫描未匹配，剩余仍为`(,*,(,*`。如果第二遍扫描先匹配左侧最左边的左括号，第二遍扫描匹配第一个星号和左括号后剩下`*,(`，会得到false。但如果先匹配最右边的左括号则会得到true。结果应该为true。
#### (1.4)
伪代码如下：
```C
bool match(char input[], int n) {
    int left[n] = {-1}, posLeft=-1;//left和star存储扫描到的左括号和星号在input中的下标
    int star[n] = {-1}, posStar=-1;//posStar和posLeft指的是最右边的星号/左括号在left和star中的下标
    for(int i = 0; i < n; i++) {//从左向右扫描
        if(input[i] == '(') {//按从左到右顺序存左括号
            posLeft++;
            left[posLeft] = i;
        }
        else if(input[i] == '*') {//按从左到右顺序存星号
            posStar++;
            star[posStar] = i;
        }
        else {//遇到右括号
            if(posLeft > -1) {//先匹配最右边的左括号
                left[posLeft] = -1;
                posLeft--;
            }
            else if(posStar > -1) {//否则匹配最右边的星号
                star[posStar] = -1;
                posStar--;
            }
            else return false;
        }
    }
    if(posLeft < 0) //第一遍扫描结束，左括号和右括号都匹配完了
        return true;
    else {
        int i = 0;
        while(i <= posLeft && posStar >= 0) {//从右向左扫描
            if(left[posLeft] > star[posStar])//当前最右边的是左括号
                return false;
            else {//当前最右边的是星号，匹配左括号
                star[posStar] = -1;
                posStar--;
                left[i] = -1;
                i++;
                if(i > posLeft) {//所有左括号都被匹配
                    return true;
                }
            }
        }
    }
    return false;//扫描完所有星号，仍有左括号未匹配
}
```
下面分析这个算法的时间复杂度。算法中除for循环和while循环外，其余所有操作都是常数代价的。for循环执行了n次常数代价的操作，因此必然是$O(n)$的。对于while循环，每次迭代要么返回false，要么posStar--，而posStar不会大于n，因此while循环执行不超过n次常数代价的操作，是$O(n)$的。因此整个算法的时间复杂度为$O(n)$。