## Q1
正确。证明如下：
只需证明：在外层循环第m轮迭代后，D中保存着任意两个顶点间只使用顶点1到m作为中间节点的最短路径长度。
首先，初始时D中保存着任意两个顶点间的边权（若没有边则为无穷大），那么第一轮迭代后，$d[i][j]$为$w[i][j]$和$d[i][1]+d[1][j]$中的较小者，满足条件。

假设第m-1轮迭代后，D中保存着任意两个顶点间只使用顶点1到m-1作为中间节点的最短路径长度，那么第m轮迭代后，考虑任意两个顶点i和j。i,j间仅使用顶点1到m作为中间节点的最短路径有如下两种情况：
- 1. 这条最短路径不包括顶点m，那么这条最短路径在第m-1轮迭代后已经计算出来了，就是上一轮得到的$d[i][j]$。
- 2. 这条最短路径包括顶点m，那么这条路径一定由从i到m的和从m到j的两条仅使用1到m作为中间节点的最短路径拼成。事实上，这两条最短路径只使用顶点1到m-1作为中间节点，否则路径上会有从m到m的环，将这个环去掉可以使路径更短。因此，这两条最短路径在第m-1轮迭代后已经计算出来了，就是$d[i][m]$和$d[m][j]$。即这条最短路径的长度为上一轮得到的$d[i][m]$和$d[m][j]$之和。

综上，第m轮迭代后，通过取$d[i][j]$和$d[i][m]+d[m][j]$的较小者，可以得到i,j间只使用顶点1到m作为中间节点的最短路径长度。

由数学归纳法，得证。

## Q2
伪代码如下：
```
Min-Path(G, s, k)
let D be an array of size G.V.length
for i from 1 to G.V.length
    D[i] = infinity
D[s] = 0
for i from 1 to k
    for each (u, v) in G.E
        if D[v] > D[u] + w(u, v)
            D[v] = D[u] + w(u, v)
return D
```
上述算法在第2个for循环在第m轮迭代后，D中保存着从s到任意一个顶点的仅经过至多m条边的最短路径长度。因此，k轮循环结束后，D中保存着从s到任意一个顶点的仅经过至多k条边的最短路径长度。

第一个for循环的时间复杂度为$O(|V|)$，第二个for循环外层执行$k$次，内层执行$|E|$次，因此时间复杂度为$O(k|E|)$。总的时间复杂度为$O(|V|+k|E|)$。

## Q3
$\hat{w}(u, v) = w(u, v) + \delta(s, u) - \delta(s, v)$，其中s是Johnson算法添加的顶点。
那么，只需证明对这个环路上的任意一条边$(u, v)$，有$w(u, v) = \delta(s, v) - \delta(s, u)$即可。
设环路$c(u, v)$上从$v$到$u$的路径为$p(v, u)$。$p(v, u)$的长度为$wp(v, u)$

若$\delta(s, v) > w(u, v) + \delta(s, u)$，那么很显然可以取$s$到$u$的最短路径加上边$(u, v)$构成一条从$s$到$v$的更短路径，矛盾；若$\delta(s, v) < w(u, v) + \delta(s, u)$，那么可以取$s$到$v$的最短路径加上$p(v, u)$，得到一条从$s$到$u$的更短路径（这条路径的长度为$\delta(s, v) + wp(u, v) = \delta(s, v) - w(u, v) < \delta(s, u)$），矛盾。

因此，$\delta(s, v) = w(u, v) + \delta(s, u)$，即$w(u, v) = \delta(s, v) - \delta(s, u)$。

## Q4
首先，建立一个有$ng$个顶点的图，图中的每个顶点被表示为$(i, j), i = 1, 2, ..., n,\ j = 1, 2, ..., g$。$(i, j)$表示在第$i$个顶点时有$j$点体力。
那么，存在从顶点$(i_1, j_1)$到顶点$(i_2, j_2)$的边，当且仅当以下3种情况：
- 1. 站点$x_{i_1}$和$x_{i_2}$之间有道路，且$j_1 = j_2, e_{i_1} \ge e_{i_2}$。此时这条边的权值为沿这条道路行驶所需的时间。
- 2. 站点$x_{i_1}$和$x_{i_2}$之间有道路，且$j_1 - j_2 = e_{i_2} - e_{i_1}, e_{i_1} < e_{i_2}$。此时这条边的权值为沿这条道路行驶所需的时间。
- 3. $i_1 = i_2 = i, j_2 = j_1 + 1$，且站点$x_i$是补给站。此时这条边的权值为$t_G$。

然后，用dijkstra算法求上面新建的图中顶点$(s, g)$出发到其余顶点的单源最短路。

最后，在得到的单源最短路中，取$(s, g)$到$(t, j), j = 1, 2, 3, ..., g$中最短的一条即可。

这样一个图中，顶点数为$ng = O(n^2)$。原图中的一条边在新图中至多变为$g$条，补给站增加的边为$O(n)$条，因此边数也为$O(n^2)$。那么建图的过程时间复杂度为$O(n^2)$。如果在dijkstra算法中使用斐波那契堆维护优先队列，那么时间复杂度为$O(|V|\log |V| + |E|) = O(n^2\log n^2 + n^2) = O(n^2\log n)$。最后选取最短路的过程时间复杂度为$O(g)$。因此总的时间复杂度为$O(n^2\log n)$。