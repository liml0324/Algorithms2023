## Q1
正确。证明如下：
只需证明：在外层循环第m轮迭代后，D中保存着任意两个顶点间只使用顶点1到m作为中间节点的最短路径长度。
首先，初始时D中保存着任意两个顶点间的边权（若没有边则为无穷大），那么第一轮迭代后，$d[i][j]$为$w[i][j]$和$d[i][1]+d[1][j]$中的较小者，满足条件。

假设第m-1轮迭代后，D中保存着任意两个顶点间只使用顶点1到m-1作为中间节点的最短路径长度，那么第m轮迭代后，考虑任意两个顶点i和j。i,j间仅使用顶点1到m作为中间节点的最短路径有如下两种情况：
- 1. 这条最短路径不包括顶点m，那么这条最短路径在第m-1轮迭代后已经计算出来了，就是上一轮得到的$d[i][j]$。
- 2. 这条最短路径包括顶点m，那么这条路径一定由从i到m的和从m到j的两条仅使用1到m作为中间节点的最短路径拼成。事实上，这两条最短路径只使用顶点1到m-1作为中间节点，否则路径上会有从m到m的环，将这个环去掉可以使路径更短。因此，这两条最短路径在第m-1轮迭代后已经计算出来了，就是$d[i][m]$和$d[m][j]$。即这条最短路径的长度为上一轮得到的$d[i][m]$和$d[m][j]$之和。

综上，第m轮迭代后，通过取$d[i][j]$和$d[i][m]+d[m][j]$的较小者，可以得到i,j间只使用顶点1到m作为中间节点的最短路径长度。

由数学归纳法，得证。

## Q2
伪代码如下：
```
Min-Path(G, s, k)
let D be an array of size G.V.length
for i from 1 to G.V.length
    D[i] = infinity
D[s] = 0
for i from 1 to k
    for each (u, v) in G.E
        if D[v] > D[u] + w(u, v)
            D[v] = D[u] + w(u, v)
return D
```
上述算法在第2个for循环在第m轮迭代后，D中保存着从s到任意一个顶点的仅经过至多m条边的最短路径长度。因此，k轮循环结束后，D中保存着从s到任意一个顶点的仅经过至多k条边的最短路径长度。

第一个for循环的时间复杂度为$O(|V|)$，第二个for循环外层执行$k$次，内层执行$|E|$次，因此时间复杂度为$O(k|E|)$。总的时间复杂度为$O(|V|+k|E|)$。

## Q3
$\hat{w}(u, v) = w(u, v) + \delta(s, u) - \delta(s, v)$，其中s是Johnson算法添加的顶点。
那么，只需证明对这个环路上的任意一条边$(u, v)$，有$w(u, v) = \delta(s, v) - \delta(s, u)$即可。
设环路$c(u, v)$上从$v$到$u$的路径为$p(v, u)$。$p(v, u)$的长度为$wp(v, u)$

若$\delta(s, v) > w(u, v) + \delta(s, u)$，那么很显然可以取$s$到$u$的最短路径加上边$(u, v)$构成一条从$s$到$v$的更短路径，矛盾；若$\delta(s, v) < w(u, v) + \delta(s, u)$，那么可以取$s$到$v$的最短路径加上$p(v, u)$，得到一条从$s$到$u$的更短路径（这条路径的长度为$\delta(s, v) + wp(u, v) = \delta(s, v) - w(u, v) < \delta(s, u)$），矛盾。

因此，$\delta(s, v) = w(u, v) + \delta(s, u)$，即$w(u, v) = \delta(s, v) - \delta(s, u)$。

## Q4
