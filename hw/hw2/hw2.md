# Q1
由于PARTITION过程以选中的x为分界线，将数列分为小于x和大于x的两部分，因此x与中位数越接近，划分越平衡。
当划分为$1-\alpha:\alpha$时，不妨认为有$\alpha n$个数小于x，$(1-\alpha)n$个数大于x，其中n为除x以外的数的个数。
那么要产生更平衡的划分，则新选中的x'应该比现有的x更接近中位数。由上面条件可知，中位数与x之间还有大约$(\frac12-\alpha)n$个数，由对称性，有$(1-2\alpha)n$个数比x更接近中位数，因此选中这些数中的一个，即产生更平衡的划分的概率为$1-2\alpha$。

# Q2
## (1)
首先证明：使得加权平均差最小的x为数列${a_n}$的加权中位数。加权中位数是指：假设这个数列按升序排序，从数列中最小值的权值一直累加至加权中位数的权值，等于或恰好大于0.5。
不妨假设$a_1 \leq ... \leq a_k \leq x \leq a_{k+1} \leq ... \leq a_n$
那么$D(x) = [\Sigma^k_{i=1}(x-a_i) + \Sigma^n_{i=k+1}(a_i-x)]/\Sigma w_i = [(\Sigma^n_{i=k+1}w_ia_i-\Sigma^k_{i=1}w_ia_i) + (\Sigma^k_{i=1}w_i-\Sigma^n_{i=k+1}w_i)x]$
由于当k固定时，$(\Sigma^n_{i=k+1}w_ia_i-\Sigma^k_{i=1}w_ia_i)$和$(\Sigma^k_{i=1}w_i-\Sigma^n_{i=k+1}w_i)$为定值，因此使得$D(x)$最小的x要么为$a_k$，要么为$a_{k+1}$。
一般地，使得$D(x)$最小的$x$一定等于$\{a_n\}$中的某一项。
记$D_k(x) = \Sigma^n_{i=1}w_i|a_i-a_k| = (\Sigma^n_{i=k+1}w_ia_i-\Sigma^k_{i=1}w_ia_i)+(\Sigma^k_{i=1}w_i-\Sigma^n_{i=k+1}w_i)$，这里没有考虑分母上的权值和，因为它是常数。
那么$D_{k+1}(x)-D_k(x) = (\Sigma^k_{i=1}w_i-\Sigma^n_{i=k+1}w_i)(a_{k+1}-a_k)$
由于假定$\{a_n\}$是升序序列，因此$a_{k+1}-a_k > 0$。
当$(\Sigma^k_{i=1}w_i-\Sigma^n_{i=k+1}w_i)$小于0，$D_{k+1}(x)<D_k(x)$；当$(\Sigma^k_{i=1}w_i-\Sigma^n_{i=k+1}w_i)$大于0，$D_{k+1}(x)>D_k(x)$。且$(\Sigma^k_{i=1}w_i-\Sigma^n_{i=k+1}w_i)$是随k单调增的。因此使得$\Sigma^{k-1}_{i=1}w_i-\Sigma^n_{i=k}w_i\leq0$（即$D_{k}(x)<D_{k-1}(x)$），且$\Sigma^k_{i=1}w_i-\Sigma^n_{i=k+1}w_i\ge 0$（即$D_{k}(x)<D_{k+1}(x)$）的$a_k$即为所求的x。可以看出，这个$a_k$即为前面描述的加权中位数。


模仿书上的最坏时间复杂度为线性的求中位数算法，给出下面这个算法，它可以求一个带权数列的加权中位数。这个算法的最坏时间复杂度为$O(n)$。

Algorithm: SELECT
输入: $(a_1, w_1), (a_2, w_2), ..., (a_n, w_n), \alpha$
输出：$a_m$
1. 将$(a_i, w_i)$分成$\lceil\frac n5\rceil$组，其中只有最后一组的元素个数可能少于5。令这个数组为c。

2. 对c中的元素按数列$a_i$使用插入排序进行排序，随后对每个c用普通的求中位数算法求中位数，得到c的中位数数列m。m中的元素为每组的中位数对应的数对$(a_i, w_i)$。

3. 递归地对上面得到的数列m调用上述过程，直至求出最后一对数，记为$(a_m, w_m)$。

4. 用修改过的快速排序中的PARTITION算法（即将分割点也作为输入），将数列按$a_i$大小分为小于$a_m$和大于$a_m$的两部分，分别计算两部分的权值和，将前者的权值和记为$S_1$，后者的权值和记为$S_2$。

5. 若$S_1$小于$\alpha\Sigma^n_{i=1} w_i$，且$S_2$小于等于$(1-\alpha)\Sigma^n_{i=1} w_i$，则返回$a_m$；否则，若$S_1$大于等于$\alpha\Sigma^n_{i=1} w_i$，则递归地对前一部分调用上述过程，但输入的$\alpha'$变为$\frac{\alpha\Sigma^n_{i=1} w_i}{S1}$；若$S_2$大于$(1-\alpha)\Sigma^n_{i=1}w_i$，则递归地对后一部分调用上述过程，但输入的$\alpha'$变为$\frac{\alpha (S_1+w_m+S_2)-(S_1+w_m)}{S_2}$。

该算法中，步骤1、2、4和书中原算法一样需要$O(n)$时间；步骤3也和书中一样需要$T(\lceil\frac n5\rceil)$时间；由于划分主元(a_m, w_m)和书中一样是通过不断取中位数得到的，因此第5步的递归调用也至多作用于$7n/10+6$个元素，步骤5所需时间至多为$T(7n/10+6)$。利用和书上一样的分析方法得知，最坏情况下的运行时间为线性的。

最后给出计算最小加权平均差的算法：
输入: $a_1, a_2, ..., a_n, w_1, w_2, ..., w_n$
输出: d
首先，将输入的$a_1, a_2, ..., a_n, w_1, w_2, ..., w_n$按$(a_1, w_1), (a_2, w_2), ..., (a_n, w_n)$的格式整理为一个新数组，很明显这一步的时间复杂度是$O(n)$。
随后，调用算法SELECT，输入$(a_1, w_1), (a_2, w_2), ..., (a_n, w_n), \alpha = 0.5$，求出加权中位数$a_m$，这一步的时间复杂度为$O(n)$。
最后，调用下面这段伪代码表示的算法，输入$a_1, a_2, ..., a_n, w_1, w_2, ..., w_n, x = a_m$，求出最小加权平均差d，这一步的时间复杂度为$O(n)$。
```py
input: a1, a2, ..., an, w1, w2, ..., wn, x
output: d
d = 0
for i from 1 to n:
    d += wi * abs(ai - x)
w = 0
for i from 1 to n:
    w += wi
d /= w
```
因此，上述算法即为一个求出最小加权平均差的算法，且最坏时间复杂度为$O(n)$。

## (2)*
不妨设$\Delta^k\{a_n\}$的第i项为$\Delta^ka_i$。
那么有差分数列的定义，有：
$b_n = b_1 + \Sigma^{n-1}_{i=1}\Delta^1b_i$
$\Delta^1b_n = \Delta^1b_1+\Sigma^{n-1}_{i=1}\Delta^2b_i$
由于$\{b_n\}$是周期为T的周期数列，因此有：
$\Sigma^T_{n=1}\Delta^1b_n = b_{T+1} - b_1 = b_1 - b_1 = 0$
即$\Sigma^T_{n=1}(\Delta^1b_1+\Sigma^{n-1}_{i=1}\Delta^2b_i) = T\Delta^1b_1 + \Sigma^T_{n=1}\Sigma^{n-1}_{i=1}\Delta^2b_i = 0$
即$\Delta^1b_1 = -(\Sigma^T_{n=1}\Sigma^{n-1}_{i=1}\Delta^2b_i)/T$。由于$\Delta^2\{b_n\}$可由$\{a_n\}$计算确定，因此$\Delta^1b_1$为常数。
$\Delta^1b_1$确定后，即可确定$\Delta^1b_2=\Delta^1b_1+\Delta^2b_1$，$\Delta^1b_3=\Delta^1b_2+\Delta^2b_2$，...，$\Delta^1b_T=\Delta^1b_{T-1}+\Delta^2b_{T-1}$。
那么，由$b_n = b_1 + \Sigma^{n-1}_{i=1}\Delta^1b_i$，可得$\Sigma^T_{i=1}|b_i| = \Sigma^T_{n=1}|b_n| = \Sigma^T_{n=1}|b_1 + \Sigma^{n-1}_{i=1}\Delta^1b_i|$，这个表达式和(1)中所求加权平均差的表达式非常类似，$b_1$即为(1)中的$-x$，$\Sigma^{n-1}_{i=1}\Delta^1b_i$即为(1)中的$a_n$。可以用第一问的算法在$O(T)$的时间内求出使$\Sigma^T_{n=1}|b_n|$最小的$b_1$，即长度为T，各项权值都为1的数列$\Sigma^{n-1}_{i=1}\Delta^1b_i$的加权中位数的相反数。
算法描述如下，用类C语言的伪代码描述：
```C++
Input: a1, a2, ..., aT
Output: minSum
double D2b[T+1];
for (int i = 1; i < T; i++)
    D2b[i] = a[i+1] - a[i];
D2b[T] = a[1] - a[T];
double sumD2b[T+1];
sumD2b[0] = 0;
for (int i = 1; i <= T; i++)
    sumD2b[i] = sumD2b[i-1] + D2b[i];
double D1b[n+1] = {0};
for (int i = 1; i <= T; i++)
    D1b[1] += sumD2b[i-1];
D1b[1] = -D1b[1]/T;
for (int i = 2; i <= T; i++)
    D1b[i] = D1b[i-1] + D2b[i-1];
double sumD2b[T+1];
sumD2b[0] = 0;
for (int i = 1; i <= T; i++)
    sumD2b[i] = sumD2b[i-1] + D2b[i];
double minSum = 0;
这里构造一个长度为T的数列b，使得其中第i项为(sumD2b[i-1], 1)（不妨设这个数列的下标范围是从1到T），
将这个数列输入(1)中求加权中位数的算法，求出其加权中位数x，那么-x即为使得数列b_n绝对值之和最小的b_1。
for (int i = 1; i <= T; i++)
    minSum += abs(sumD2b[i-1] - x);
return minSum;
```
分析上述算法的时间复杂度：上述算法中每个循环的迭代次数均为T，且循环体内的操作均为常数时间，因此每个循环的时间复杂度为$O(T)$；循环体外除调用(1)中的算法外，其余操作均为常数时间；而由于输入(1)中算法的数列长度为T，因此调用(1)中算法的时间复杂度也为$O(T)$。综上，算法总的时间复杂度为$O(T)$。
## Q3
### (1)
算法伪代码如下（假设数组A，B下标范围分别为从1到n和从1到m）：
```py
input: A, B, n, m
j = 1, S = 0
for i from 1 to n:
    while j <= m and A[i] > B[j]:
        j += 1
    S += j-1
return S
```
该算法的时间复杂度为$O(n+m)$。

### (2)
算法伪代码如下（假设数组L下标范围为从1到n）：
```py
function: CalcI(L, begin, end)
    if begin == end:
        return 0
    if begin == end-1:
        if L[begin] > L[end]:
            swap(L[begin], L[end])
            return 1
        else:
            return 0
    m = (begin + end) / 2
    cnt = CalcI(L, begin, m) + CalcI(L, m+1, end)
    j = m+1
    for i from begin to m:
        while j <= end and L[i] > L[j]:
            j += 1
        cnt += j-m-1
    return cnt
```
调用CalcI(L, 1, n)即可求出逆序数对的个数，该算法的时间复杂度为$O(n\log n)$。
该算法在计算逆序数的同时会对L进行排序。如果不想改变L的顺序，可以将L复制一份再传入CalcI中。复制L的时间复杂度为$O(n)$，因此总的时间复杂度仍为$O(n\log n)$。

## Q4
### (1)
**算法1：**
是完备的。原因如下：
不妨设输入的初始序列为$L_1, L_2, ..., L_k$，下面证明，对于任意一个目标序列$L_{k_1}, L_{k_2}, ..., L_{k_n}$，都有可能通过该算法得到。
为证明其正确性，将数列L在循环中具有的性质表示为如下这个循环不变式：
在该循环每次迭代开始时，数列L中的1到i-1个元素**有可能**恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{i-1}}$。
下面证明这个循环不变式的三条性质：
**初始化：** 开始前i为1，1到0之间没有元素，满足该性质。
**保持：** 若i=m这一次循坏开始前该性质成立，即数列L中的1到m-1个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m-1}}$。那么如果数列L中的1到m-1个元素恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m-1}}$，则此时$L_{k_m}$一定在数列L的第m到n个元素中。由于j有可能取得[1, n]之间任意整数，因此j有可能取得$L_{k_m}$在当前数列L中的下标。如果恰好取得该下标，则进行交换后L[k]变为$L_{k_m}$，$L_{k_m}$，且由于原本在数列L的第m到n个元素中，因此交换后L中第1到m-1个元素未发生改变，数列L中的1到m个元素恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m}}$。因此第m+1次循环开始前，数列L中的1到m个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m}}$。循环不变式保持。
**终止：** 当i为n+1时循环终止，此时数列L中的1到n个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{n}}$。
根据循环不变式的性质，对于任意的目标序列$L_{k_1}, L_{k_2}, ..., L_{k_n}$，都有可能通过该算法得到。因此该算法是完备的。

**算法2：**
是完备的。原因如下：
不妨设输入的初始序列为$L_1, L_2, ..., L_k$，下面证明，对于任意一个目标序列$L_{k_1}, L_{k_2}, ..., L_{k_n}$，都有可能通过该算法得到。
为证明其正确性，将数列L在循环中具有的性质表示为如下这个循环不变式：
在外层循环每次迭代开始时，数列L中的1到i-1个元素**有可能**恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{i-1}}$。
下面证明这个循环不变式的三条性质：
**初始化：** 开始前i为1，1到0之间没有元素，满足该性质。
**保持：** 若i=m这一次循坏开始前该性质成立，即数列L中的1到m-1个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m-1}}$。那么如果数列L中的1到m-1个元素恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m-1}}$，则此时$L_{k_m}$一定在数列L的第m到n个元素中。不妨设$L_{k_m}$此时是数列L中第t个，那么只需在j不为t时randint(0, 1)均取0，j为t时取1，即可将$L_{k_m}$交换到数列L的第m个位置。而这是有可能取到的。并且，由于交换前$L_{k_m}$一定在数列L的第m到n个元素中，因此交换后L中第1到m-1个元素未发生改变，数列L中的1到m个元素恰好变为$L_{k_1}, L_{k_2}, ..., L_{k_{m}}$。因此第m+1次循环开始前，数列L中的1到m个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m}}$。循环不变式保持。
**终止：** 当i为n+1时循环终止，此时数列L中的1到n个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{n}}$。
根据循环不变式的性质，对于任意的目标序列$L_{k_1}, L_{k_2}, ..., L_{k_n}$，都有可能通过该算法得到。因此该算法是完备的。

**算法3：**
是完备的。原因如下：
不妨设输入的初始序列为$L_1, L_2, ..., L_k$，下面证明，对于任意一个目标序列$L_{k_1}, L_{k_2}, ..., L_{k_n}$，都有可能通过该算法得到。
为证明其正确性，将数列L在循环中具有的性质表示为如下这个循环不变式：
在外层循环每次迭代开始时，数列L中的1到i-1个元素**有可能**恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{i-1}}$。
下面证明这个循环不变式的三条性质：
**初始化：** 开始前i为1，1到0之间没有元素，满足该性质。
**保持：** 若i=m这一次循坏开始前该性质成立，即数列L中的1到m-1个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m-1}}$。那么如果数列L中的1到m-1个元素恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m-1}}$，则此时$L_{k_m}$一定在数列L的第m到n个元素中。不妨设$L_{k_m}$此时是数列L中第t个，那么只需在i取m，j取t，即可将$L_{k_m}$交换到数列L的第m个位置。而i和j用randint函数在[1, n]间随机取值，因此这是有可能取到的。并且，由于交换前$L_{k_m}$一定在数列L的第m到n个元素中，因此交换后L中第1到m-1个元素未发生改变，数列L中的1到m个元素恰好变为$L_{k_1}, L_{k_2}, ..., L_{k_{m}}$。因此第m+1次循环开始前，数列L中的1到m个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m}}$。循环不变式保持。
**终止：** 当i为n+1时循环终止，此时数列L中的1到n个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{n}}$。
根据循环不变式的性质，对于任意的目标序列$L_{k_1}, L_{k_2}, ..., L_{k_n}$，都有可能通过该算法得到。因此该算法是完备的。

**算法4：**
是完备的。原因如下：
不妨设输入的初始序列为$L_1, L_2, ..., L_k$，下面证明，对于任意一个目标序列$L_{k_1}, L_{k_2}, ..., L_{k_n}$，都有可能通过该算法得到。
为证明其正确性，将数列L在循环中具有的性质表示为如下这个循环不变式：
在该循环每次迭代开始时，数列L中的1到i-1个元素**有可能**恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{i-1}}$。
下面证明这个循环不变式的三条性质：
**初始化：** 开始前i为1，1到0之间没有元素，满足该性质。
**保持：** 若i=m这一次循坏开始前该性质成立，即数列L中的1到m-1个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m-1}}$。那么如果数列L中的1到m-1个元素恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m-1}}$，则此时$L_{k_m}$一定在数列L的第m到n个元素中。由于j有可能取得[i, n]之间任意整数，因此j有可能取得$L_{k_m}$在当前数列L中的下标。如果恰好取得该下标，则进行交换后L[k]变为$L_{k_m}$，$L_{k_m}$。且由于原本在数列L的第m到n个元素中，因此交换后L中第1到m-1个元素未发生改变，数列L中的1到m个元素恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m}}$。因此第m+1次循环开始前，数列L中的1到m个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{m}}$。循环不变式保持。
**终止：** 当i为n+1时循环终止，此时数列L中的1到n个元素 **有可能** 恰好为$L_{k_1}, L_{k_2}, ..., L_{k_{n}}$。
根据循环不变式的性质，对于任意的目标序列$L_{k_1}, L_{k_2}, ..., L_{k_n}$，都有可能通过该算法得到。因此该算法是完备的。

### (2)
**算法1：** 不是均匀的。原因如下：
考虑n为3的情况，此时循环需迭代3次。假设每次迭代时j取的值分别为$j_1, j_2, j_3$，它们的取值范围均为$1, 2, 3$。在数列L确定的情况下，每一个确定的$j_1, j_2, j_3$序列都对应一个唯一确定的L的排列。且由于randint是随机的，且每次randint取值是独立分布的，因此取得每一个$j_1, j_2, j_3$序列的概率都相等。这样的$j_1, j_2, j_3$序列有$3^3=27$种，而L的排列有$3!=6$种，$6 \nmid 27$，因此必然存在至少2种L的排列生成概率不同，该算法不是均匀的。
（事实上，对任意$n \ge 3$，该算法都不是均匀的。因为$n^n$的质因子中不可能包含所有小于等于$n$的素数，而$n!$中是包含的。）

**算法2：** 不是均匀的。原因如下：
与算法1的情况类似，对于任意给定的n和L，该算法在$n^2$次迭代中会生成长度为$n^2$的随机的0,1序列，每一个序列都唯一对应一个L的排列，且每一个序列生成的概率相等。这样的序列共有$2^{n^2}$种，L的排列有$n!$种。而对于任意的$n \ge 3$，$n!$都有质因子3，$2^{n^2}$中只有唯一的质因子2，因此$n! \nmid 2^{n^2}$，该算法不是均匀的。

**算法3：** 不是均匀的。原因如下：
与算法1的情况类似，考虑n为3的情况。此时循环迭代3次，每次迭代取得的i和j的值可构成序列$(i_1, j_1), (i_2, j_2), (i_3, j_3)$。每一个这样的序列产生的可能性相同，且对应一个唯一的L的排列。这样的序列共有$3^6=729$种，L的排列有$3!=6$种，$6 \nmid 729$，因此该算法不是均匀的。

**算法4：** 是均匀的。原因如下：
对于任意给定的n和L，该算法需迭代n次，每次迭代时取得的j的值可构成序列$j_1, j_2, ..., j_n$，且第i次迭代时j的取值范围为$[i, n]$内的整数，因此$j_1, j_2, ..., j_n$的序列共有$n!$种。每一个这样的排列生成的可能性相同，且都唯一的对应一个L的排列。且由(1)中的证明，算法4是完备的，因此每一个L的排列都至少对应一个$j_1, j_2, ..., j_n$序列。L的排列也有$n!$种。由此可知，$j_1, j_2, ..., j_n$序列和L的排列之间是一个双射，因此L的每一种排列生成的可能性都是相同的（为$\frac{1}{n!}$）。该算法是均匀的。

### (*3.1)
正确。考虑一个输入序列$L_1, L_2, ..., L_n$，对于任意的一个目标序列$L_{k_1}, L_{k_2}, ..., L_{k_n}$，考虑打乱到这个目标序列的概率：
首先，需要将$L_{k_1}$打乱到第1个位置，概率为$\frac1n$；然后需要将$L_{k_2}$打乱到第二个位置，此时还剩下$n-1$个数，概率为$\frac{1}{n-1}$……以此类推，打乱到这个目标序列的概率为$\frac{1}{n!}$。由于L有$n!$种排列，且打乱到任意一种排列的概率恰为$\frac{1}{n!}$，因此该打乱算法是均匀的。

### (*3.2)
错误。
对于一个输入的序列L，可以为它的$n!$种排列确定一个顺序（比如对于每种排列，将所有数字从前往后连接成一个数字，数字大的排列在前，数字小的排列在后，这样就可以确定一个顺序），那么对L的每种排列都可以确定一个编号，且该编号至于这个排列本身有关，与被打乱到它的原排列无关。有了这样的编号方式，就可以把每一种排列对应到一个状态，将打乱的过程看作一个马尔可夫过程。由于该打乱算法是完备的，因此有$\forall i, j \in [1, n!], p_{ij} > 0$，且$\forall i \in [1, n!], \Sigma^{n!}_{j=1}p_{ij} = 1$。更进一步，这个马尔可夫过程种任意两个状态互达，因此是不可约的。又由于这个马尔可夫过程的状态数有限，因此每个状态都是正常返的。
且由于对任意一种状态$i$，有$p^{(n)}_{ii} \ge p^n_{ii} > 0$，因此任意一个状态都是非周期的。这个马氏链非周期、不可约、正常返、状态有限，因此一定存在唯一的平稳分布。平稳分布满足下面这个方程组：
$$\forall j \in [1, n!], \pi_j = \Sigma^{n!}_{i=1}\pi_ip_{ij}$$
$$\Sigma^{n!}_{i=1}\pi = 1$$
由于$\forall i \in [1, n!], \Sigma^{n!}_{j=1}p_{ij} = 1$
由非周期和正常返性，此时所有的状态都是遍历态，因此$\lim_{n\rightarrow \infin}p^{(n)}_{ij} = \pi_j$，若重复执行多次，最后的结果趋向均匀，则所有的$\lim_{n\rightarrow \infin}p^{(n)}_{ij} = \pi_j$都应为$\frac1{n!}$。然而，很显然$\forall j \in [1, n!], \pi_j = \frac1{n!}$仅在$\forall j \in [1, n!] \Sigma^{n!}_{i=1}p_{ij}=1$时满足方程组，那么只需取$p_{i1}均为0.99$，其余$p_{ij}$平分剩下的概率，即可使$\forall j \in [1, n!], \pi_j = \frac1{n!}$不满足方程组，即执行多次后的打乱算法不趋于均匀。

## *Q5
### (*1)
只需证明该关系对$X^m$上的任意元素满足自反性和传递性即可。
**自反性：** 对于$X^m$上的任意元素$(a_1, a_2, ..., a_m)$，有$\mathop{\stackrel{m}{\bigwedge}}\limits_{i=1}a_i \sim a_i$，因此该关系满足自反性。
**传递性：** 考虑$X^m$上任意的3个元素：$(a_1, a_2, ..., a_m)$，$(b_1, b_2, ..., b_m)$，$(c_1, c_2, ..., c_m)$，设它们分别为$A, B, C$。那么只需证明：若$A \lesssim_m B, B \lesssim_m C$，则$A \lesssim_m C$。
当$A \lesssim_m B, B \lesssim_m C$时：
- 若有$\mathop{\stackrel{m}{\bigwedge}}\limits_{i=1}a_i \sim b_i$且$\mathop{\stackrel{m}{\bigwedge}}\limits_{i=1}b_i \sim c_i$（这样的关系下面简记为$A \sim_m B, B \sim_m C$），则由等价关系的传递性，有$\mathop{\stackrel{m}{\bigwedge}}\limits_{i=1}a_i \sim c_i$。此时$A \lesssim_m C$。
- 若$\mathop{\stackrel{m-1}{\bigvee}}\limits_{i=0}((a_{i+1} < b_{i+1})\bigwedge (\mathop{\stackrel{i}{\bigwedge}}\limits_{j=1}a_j\sim b_j))$且$B \sim_m C$，分析可知，$(a_{i+1} < b_{i+1})\bigwedge (\mathop{\stackrel{i}{\bigwedge}}\limits_{j=1}a_j\sim b_j)$共有m种情况，设$i=k$时该式为真，即$(a_{k+1} < b_{k+1})\bigwedge (\mathop{\stackrel{k}{\bigwedge}}\limits_{j=1}a_j\sim b_j)$。则由等价关系的传递性，有$\mathop{\stackrel{k}{\bigwedge}}\limits_{j=1}a_j\sim c_j$，且由$b_{k+1}\sim c_{k+1}, a_{k+1} < b_{k+1}$，有$a_{k+1} < c_{k+1}$，因此有$(a_{k+1} < c_{k+1})\bigwedge (\mathop{\stackrel{k}{\bigwedge}}\limits_{j=1}a_j\sim c_j)$，即$\mathop{\stackrel{m-1}{\bigvee}}\limits_{i=0}((a_{i+1} < c_{i+1})\bigwedge (\mathop{\stackrel{i}{\bigwedge}}\limits_{j=1}a_j\sim c_j))$成立，$A \lesssim_m C$。
- 若$A\sim B$且$\mathop{\stackrel{m-1}{\bigvee}}\limits_{i=0}((b_{i+1} < c_{i+1})\bigwedge (\mathop{\stackrel{i}{\bigwedge}}\limits_{j=1}b_j\sim c_j))$，设$(b_{s+1} < c_{s+1})\bigwedge (\mathop{\stackrel{s}{\bigwedge}}\limits_{j=1}b_j\sim c_j)$为真，那么同理有$\mathop{\stackrel{i}{\bigwedge}}\limits_{j=1}a_j\sim c_j$，且$a_{s+1} < c_{s+1}$，因此$(a_{k+1} < c_{k+1})\bigwedge (\mathop{\stackrel{k}{\bigwedge}}\limits_{j=1}a_j\sim c_j)$，即$\mathop{\stackrel{m-1}{\bigvee}}\limits_{i=0}((a_{i+1} < c_{i+1})\bigwedge (\mathop{\stackrel{i}{\bigwedge}}\limits_{j=1}a_j\sim c_j))$成立，$A \lesssim_m C$。
- 若$\mathop{\stackrel{m-1}{\bigvee}}\limits_{i=0}((a_{i+1} < b_{i+1})\bigwedge (\mathop{\stackrel{i}{\bigwedge}}\limits_{j=1}a_j\sim b_j))$且$\mathop{\stackrel{m-1}{\bigvee}}\limits_{i=0}((b_{i+1} < c_{i+1})\bigwedge (\mathop{\stackrel{i}{\bigwedge}}\limits_{j=1}b_j\sim c_j))$，设$(a_{k+1} < b_{k+1})\bigwedge (\mathop{\stackrel{k}{\bigwedge}}\limits_{j=1}a_j\sim b_j)$和$(b_{s+1} < c_{s+1})\bigwedge (\mathop{\stackrel{s}{\bigwedge}}\limits_{j=1}b_j\sim c_j)$成立。若$k > s$，则有$\mathop{\stackrel{s+1}{\bigwedge}}\limits_{j=1}a_j\sim b_j$，与上面同理可知有$\mathop{\stackrel{s}{\bigwedge}}\limits_{j=1}a_j\sim c_j$，且$a_{s+1} < c_{s+1}$；若$k < s$，则有$\mathop{\stackrel{k+1}{\bigwedge}}\limits_{j=1}b_j\sim c_j$，同理可知有$\mathop{\stackrel{k}{\bigwedge}}\limits_{j=1}a_j\sim c_j$，且$a_{k+1} < c_{k+1}$；若$k=s$，则有$\mathop{\stackrel{k}{\bigwedge}}\limits_{j=1}a_j\sim b_j$且$\mathop{\stackrel{k}{\bigwedge}}\limits_{j=1}b_j\sim c_j$，且 $a_{k+1}<b_{k+1}, b_{k+1} < c_{k+1}$ 由等价关系和偏序关系的传递性可知$\mathop{\stackrel{k}{\bigwedge}}\limits_{j=1}a_j\sim c_j$，且$a_{k+1} < c_{k+1}$。因此无论k和s之间为什么关系，都有$\mathop{\stackrel{m-1}{\bigvee}}\limits_{i=0}((a_{i+1} < c_{i+1})\bigwedge (\mathop{\stackrel{i}{\bigwedge}}\limits_{j=1}a_j\sim c_j))$成立，$A \lesssim_m C$。
综上，$A \lesssim_m C$，该关系满足传递性。
该关系对$X^m$中所有元素满足自反性和传递性，是全预序关系。